<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Optimized Pose Mocap to Roblox</title>

<style>
body {
  background: #000;
  color: #0f0;
  font-family: monospace;
}
video, canvas {
  position: absolute;
  top: 0;
  left: 0;
}
#ui {
  position: fixed;
  right: 10px;
  top: 10px;
  width: 420px;
}
button {
  width: 100%;
  padding: 10px;
  margin-bottom: 8px;
}
textarea {
  width: 100%;
  height: 420px;
  background: #000;
  color: #00ff88;
}
</style>
</head>

<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas" width="640" height="360"></canvas>

<div id="ui">
  <button id="record">Record 10s Mocap</button>
  <textarea id="output"></textarea>
</div>

<script type="module">
import {
  FilesetResolver,
  PoseLandmarker,
  DrawingUtils
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8";

const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const output = document.getElementById("output");
const recordBtn = document.getElementById("record");

let landmarker;
let drawer;
let recording = false;
let frames = [];

let lastDetect = 0;
const DETECT_INTERVAL = 33;

async function init() {
  const stream = await navigator.mediaDevices.getUserMedia({
    video: {
      width: { ideal: 640 },
      height: { ideal: 360 },
      frameRate: { ideal: 30, max: 30 }
    }
  });

  video.srcObject = stream;
  await video.play();

  const resolver = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm"
  );

  landmarker = await PoseLandmarker.createFromOptions(resolver, {
    baseOptions: {
      modelAssetPath:
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task"
    },
    runningMode: "VIDEO",
    numPoses: 1
  });

  drawer = new DrawingUtils(ctx);
  requestAnimationFrame(loop);
}

function drawBox(indices, lm, color) {
  const xs = indices.map(i => lm[i].x * canvas.width);
  const ys = indices.map(i => lm[i].y * canvas.height);

  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.strokeRect(
    Math.min(...xs),
    Math.min(...ys),
    Math.max(...xs) - Math.min(...xs),
    Math.max(...ys) - Math.min(...ys)
  );
}

function loop() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  const now = performance.now();
  let result = null;

  if (now - lastDetect >= DETECT_INTERVAL) {
    result = landmarker.detectForVideo(video, now);
    lastDetect = now;
  }

  if (result?.poseLandmarks?.[0]) {
    const lm = result.poseLandmarks[0];

    drawer.drawConnectors(
      lm,
      PoseLandmarker.POSE_CONNECTIONS,
      { color: "#00ff00", lineWidth: 2 }
    );

    drawer.drawLandmarks(
      lm,
      { color: "#ff3333", lineWidth: 1 }
    );

    drawBox([11,12,23,24], lm, "#00ffff");
    drawBox([11,13,15], lm, "#ff00ff");
    drawBox([12,14,16], lm, "#ff00ff");
    drawBox([23,25,27], lm, "#ffff00");
    drawBox([24,26,28], lm, "#ffff00");
  }

  if (recording && result?.worldLandmarks?.[0]) {
    frames.push(result.worldLandmarks[0]);
  }

  requestAnimationFrame(loop);
}

function vec(a, b) {
  return { x: b.x - a.x, y: b.y - a.y, z: b.z - a.z };
}

function toCFrame(v) {
  const yaw = Math.atan2(v.x, v.z);
  const pitch = -Math.atan2(v.y, Math.sqrt(v.x*v.x + v.z*v.z));
  return `CFrame.Angles(${pitch.toFixed(3)}, ${yaw.toFixed(3)}, 0)`;
}

recordBtn.onclick = async () => {
  frames = [];
  recording = true;
  recordBtn.disabled = true;
  recordBtn.textContent = "Recording...";

  await new Promise(r => setTimeout(r, 10000));

  recording = false;
  recordBtn.disabled = false;
  recordBtn.textContent = "Record 10s Mocap";

  exportLua();
};

function exportLua() {
  let lua = "";
  const dt = (1 / 30).toFixed(3);

  frames.forEach((p, i) => {
    lua += `local function kf${i+1}()\n`;

    const joints = {
      LeftShoulder: vec(p[11], p[13]),
      LeftElbow: vec(p[13], p[15]),
      RightShoulder: vec(p[12], p[14]),
      RightElbow: vec(p[14], p[16]),
      LeftHip: vec(p[23], p[25]),
      LeftKnee: vec(p[25], p[27]),
      RightHip: vec(p[24], p[26]),
      RightKnee: vec(p[26], p[28])
    };

    for (const j in joints) {
      lua += `  ${j}.Transform = ${toCFrame(joints[j])}\n`;
    }

    lua += `end\n\n`;
  });

  frames.forEach((_, i) => {
    lua += `kf${i+1}()\n`;
    lua += `task.wait(${dt})\n`;
  });

  output.value = lua;
}

init();
</script>

</body>
</html>
