<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Browser Mocap to Roblox</title>

<style>
body {
  background: #000;
  color: #0f0;
  font-family: monospace;
}
video, canvas {
  position: absolute;
  top: 0;
  left: 0;
}
#ui {
  position: fixed;
  right: 10px;
  top: 10px;
  width: 420px;
}
button {
  width: 100%;
  padding: 10px;
  margin-bottom: 8px;
}
textarea {
  width: 100%;
  height: 420px;
  background: #000;
  color: #00ff88;
}
</style>
</head>

<body>

<video id="video" autoplay playsinline></video>
<canvas id="canvas"></canvas>

<div id="ui">
  <button id="record">Record 10s Mocap</button>
  <textarea id="output"></textarea>
</div>

<script type="module">
import {
  FilesetResolver,
  PoseLandmarker,
  DrawingUtils
} from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8";

const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const output = document.getElementById("output");
const recordBtn = document.getElementById("record");

let landmarker;
let drawer;
let recording = false;
let frames = [];
let startTime = 0;

async function init() {
  const stream = await navigator.mediaDevices.getUserMedia({ video: true });
  video.srcObject = stream;
  await video.play();

  const resolver = await FilesetResolver.forVisionTasks(
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm"
  );

  landmarker = await PoseLandmarker.createFromOptions(resolver, {
    baseOptions: {
      modelAssetPath:
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task"
    },
    runningMode: "VIDEO",
    numPoses: 1
  });

  drawer = new DrawingUtils(ctx);
  requestAnimationFrame(loop);
}

function loop() {
  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(video, 0, 0);

  const now = performance.now();
  const result = landmarker.detectForVideo(video, now);

  if (result.poseLandmarks?.[0]) {
    // DEBUG SKELETON
    drawer.drawConnectors(
      result.poseLandmarks[0],
      PoseLandmarker.POSE_CONNECTIONS,
      { color: "#00ff00", lineWidth: 3 }
    );
    drawer.drawLandmarks(
      result.poseLandmarks[0],
      { color: "#ff0000", lineWidth: 2 }
    );
  }

  if (recording && result.worldLandmarks?.[0]) {
    frames.push(result.worldLandmarks[0]);
  }

  requestAnimationFrame(loop);
}

function vec(a, b) {
  return { x: b.x - a.x, y: b.y - a.y, z: b.z - a.z };
}

function toCFrame(v) {
  const yaw = Math.atan2(v.x, v.z);
  const pitch = -Math.atan2(v.y, Math.sqrt(v.x*v.x + v.z*v.z));
  return `CFrame.Angles(${pitch.toFixed(3)}, ${yaw.toFixed(3)}, 0)`;
}

recordBtn.onclick = async () => {
  frames = [];
  recording = true;
  startTime = performance.now();

  recordBtn.disabled = true;
  recordBtn.textContent = "Recording...";

  await new Promise(r => setTimeout(r, 10000));

  recording = false;
  recordBtn.disabled = false;
  recordBtn.textContent = "Record 10s Mocap";

  exportLua();
};

function exportLua() {
  let lua = "";

  frames.forEach((p, i) => {
    lua += `local function kf${i+1}()\n`;

    const joints = {
      LeftShoulder: vec(p[11], p[13]),
      LeftElbow: vec(p[13], p[15]),
      RightShoulder: vec(p[12], p[14]),
      RightElbow: vec(p[14], p[16]),
      LeftHip: vec(p[23], p[25]),
      LeftKnee: vec(p[25], p[27]),
      RightHip: vec(p[24], p[26]),
      RightKnee: vec(p[26], p[28])
    };

    for (const j in joints) {
      lua += `  ${j}.Transform = ${toCFrame(joints[j])}\n`;
    }

    lua += `end\n`;
    lua += `kf${i+1}()\n`;
    lua += `task.wait(0.033)\n\n`;
  });

  output.value = lua;
}

init();
</script>

</body>
</html>
