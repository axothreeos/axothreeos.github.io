<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Path Tracer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #container {
            max-width: 1200px;
            width: 100%;
        }
        canvas {
            width: 100%;
            height: auto;
            border: 2px solid #333;
            border-radius: 8px;
            image-rendering: pixelated;
        }
        .controls {
            margin-top: 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        label {
            font-size: 12px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        input[type="range"] {
            width: 100%;
        }
        input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }
        button {
            padding: 12px 24px;
            background: #4a9eff;
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.3s;
        }
        button:hover {
            background: #3a8eef;
        }
        .stats {
            margin-top: 10px;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 8px;
            font-size: 14px;
            color: #aaa;
        }
        .value {
            color: #4a9eff;
            font-weight: bold;
        }
        h1 {
            text-align: center;
            margin-bottom: 10px;
        }
        .description {
            text-align: center;
            color: #888;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>Advanced Path Tracer</h1>
        <p class="description">Real-time path tracing with depth of field, chromatic aberration, volumetric lighting & soft shadows</p>
        
        <canvas id="canvas"></canvas>
        
        <div class="controls">
            <div class="control-group">
                <label>Samples Per Frame: <span class="value" id="samplesValue">1</span></label>
                <input type="range" id="samples" min="1" max="4" value="1">
            </div>
            
            <div class="control-group">
                <label>Max Bounces: <span class="value" id="bouncesValue">5</span></label>
                <input type="range" id="bounces" min="2" max="10" value="5">
            </div>
            
            <div class="control-group">
                <label>Aperture (DOF): <span class="value" id="apertureValue">0.15</span></label>
                <input type="range" id="aperture" min="0" max="0.5" step="0.01" value="0.15">
            </div>
            
            <div class="control-group">
                <label>Focus Distance: <span class="value" id="focusValue">8.0</span></label>
                <input type="range" id="focus" min="3" max="15" step="0.1" value="8.0">
            </div>
            
            <div class="control-group">
                <label>Chromatic Aberration: <span class="value" id="aberrationValue">0.02</span></label>
                <input type="range" id="aberration" min="0" max="0.1" step="0.005" value="0.02">
            </div>
            
            <div class="control-group">
                <label>Volumetric Density: <span class="value" id="volumeValue">0.05</span></label>
                <input type="range" id="volume" min="0" max="0.2" step="0.01" value="0.05">
            </div>
            
            <div class="control-group">
                <label>Camera Rotation: <span class="value" id="rotationValue">0.0</span></label>
                <input type="range" id="rotation" min="0" max="6.28" step="0.1" value="0">
            </div>
            
            <div class="control-group">
                <button id="reset">Reset Accumulation</button>
            </div>
        </div>
        
        <div class="stats">
            <div>Frame: <span class="value" id="frameCount">0</span></div>
            <div>FPS: <span class="value" id="fps">0</span></div>
            <div>Resolution: <span class="value" id="resolution">800x600</span></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Settings
        const WIDTH = 800;
        const HEIGHT = 600;
        canvas.width = WIDTH;
        canvas.height = HEIGHT;
        
        let settings = {
            samplesPerFrame: 1,
            maxBounces: 5,
            aperture: 0.15,
            focusDistance: 8.0,
            chromaticAberration: 0.02,
            volumetricDensity: 0.05,
            cameraRotation: 0.0
        };
        
        let frameCount = 0;
        let accumBuffer = new Float32Array(WIDTH * HEIGHT * 3);
        let imageData = ctx.createImageData(WIDTH, HEIGHT);
        let lastTime = performance.now();
        let fps = 0;
        
        // Vector math utilities
        class Vec3 {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x; this.y = y; this.z = z;
            }
            
            add(v) { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
            sub(v) { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
            mul(s) { return new Vec3(this.x * s, this.y * s, this.z * s); }
            mulVec(v) { return new Vec3(this.x * v.x, this.y * v.y, this.z * v.z); }
            div(s) { return new Vec3(this.x / s, this.y / s, this.z / s); }
            dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z; }
            cross(v) {
                return new Vec3(
                    this.y * v.z - this.z * v.y,
                    this.z * v.x - this.x * v.z,
                    this.x * v.y - this.y * v.x
                );
            }
            length() { return Math.sqrt(this.dot(this)); }
            normalize() { 
                const len = this.length();
                return len > 0 ? this.div(len) : new Vec3(0, 0, 0);
            }
            reflect(n) {
                return this.sub(n.mul(2 * this.dot(n)));
            }
        }
        
        // Random number generator with seed
        let seed = Math.random() * 10000;
        function random() {
            seed = (seed * 9301 + 49297) % 233280;
            return seed / 233280;
        }
        
        function randomInUnitDisk() {
            while (true) {
                const p = new Vec3(random() * 2 - 1, random() * 2 - 1, 0);
                if (p.dot(p) < 1) return p;
            }
        }
        
        function randomInUnitSphere() {
            while (true) {
                const p = new Vec3(random() * 2 - 1, random() * 2 - 1, random() * 2 - 1);
                if (p.dot(p) < 1) return p;
            }
        }
        
        function randomUnitVector() {
            return randomInUnitSphere().normalize();
        }
        
        // Ray class
        class Ray {
            constructor(origin, direction) {
                this.origin = origin;
                this.direction = direction.normalize();
            }
            
            at(t) {
                return this.origin.add(this.direction.mul(t));
            }
        }
        
        // Material types
        const MaterialType = {
            DIFFUSE: 0,
            METAL: 1,
            GLASS: 2,
            EMISSIVE: 3
        };
        
        // Sphere class
        class Sphere {
            constructor(center, radius, material) {
                this.center = center;
                this.radius = radius;
                this.material = material;
            }
            
            intersect(ray, tMin, tMax) {
                const oc = ray.origin.sub(this.center);
                const a = ray.direction.dot(ray.direction);
                const halfB = oc.dot(ray.direction);
                const c = oc.dot(oc) - this.radius * this.radius;
                const discriminant = halfB * halfB - a * c;
                
                if (discriminant < 0) return null;
                
                const sqrtD = Math.sqrt(discriminant);
                let t = (-halfB - sqrtD) / a;
                
                if (t < tMin || t > tMax) {
                    t = (-halfB + sqrtD) / a;
                    if (t < tMin || t > tMax) return null;
                }
                
                const point = ray.at(t);
                const normal = point.sub(this.center).div(this.radius);
                
                return {
                    t: t,
                    point: point,
                    normal: normal,
                    material: this.material
                };
            }
        }
        
        // Plane class (infinite)
        class Plane {
            constructor(point, normal, material) {
                this.point = point;
                this.normal = normal.normalize();
                this.material = material;
            }
            
            intersect(ray, tMin, tMax) {
                const denom = this.normal.dot(ray.direction);
                if (Math.abs(denom) < 1e-6) return null;
                
                const t = this.point.sub(ray.origin).dot(this.normal) / denom;
                if (t < tMin || t > tMax) return null;
                
                return {
                    t: t,
                    point: ray.at(t),
                    normal: this.normal,
                    material: this.material
                };
            }
        }
        
        // Scene setup with complex geometry
        const scene = {
            objects: [
                // Ground plane
                new Plane(
                    new Vec3(0, -1, 0),
                    new Vec3(0, 1, 0),
                    { type: MaterialType.DIFFUSE, albedo: new Vec3(0.8, 0.8, 0.8), roughness: 1.0 }
                ),
                
                // Back wall
                new Plane(
                    new Vec3(0, 0, -15),
                    new Vec3(0, 0, 1),
                    { type: MaterialType.DIFFUSE, albedo: new Vec3(0.5, 0.5, 0.7), roughness: 1.0 }
                ),
                
                // Left glass sphere
                new Sphere(
                    new Vec3(-3, 0.5, -8),
                    1.5,
                    { type: MaterialType.GLASS, albedo: new Vec3(1, 1, 1), ior: 1.5 }
                ),
                
                // Center metallic sphere
                new Sphere(
                    new Vec3(0, 0, -8),
                    1.0,
                    { type: MaterialType.METAL, albedo: new Vec3(1.0, 0.8, 0.5), roughness: 0.1 }
                ),
                
                // Right diffuse sphere
                new Sphere(
                    new Vec3(2.5, 0, -7),
                    1.0,
                    { type: MaterialType.DIFFUSE, albedo: new Vec3(0.8, 0.2, 0.2), roughness: 1.0 }
                ),
                
                // Small glass ball
                new Sphere(
                    new Vec3(-1, -0.3, -5),
                    0.7,
                    { type: MaterialType.GLASS, albedo: new Vec3(1, 1, 1), ior: 1.5 }
                ),
                
                // Emissive sphere (light)
                new Sphere(
                    new Vec3(4, 5, -8),
                    2.0,
                    { type: MaterialType.EMISSIVE, emission: new Vec3(8, 6, 4) }
                ),
                
                // Secondary light
                new Sphere(
                    new Vec3(-5, 3, -6),
                    1.5,
                    { type: MaterialType.EMISSIVE, emission: new Vec3(2, 4, 8) }
                ),
                
                // Small metal sphere
                new Sphere(
                    new Vec3(1.5, -0.5, -5.5),
                    0.5,
                    { type: MaterialType.METAL, albedo: new Vec3(0.7, 0.7, 0.9), roughness: 0.3 }
                ),
                
                // Decorative spheres
                new Sphere(
                    new Vec3(-2, -0.6, -6),
                    0.4,
                    { type: MaterialType.DIFFUSE, albedo: new Vec3(0.2, 0.8, 0.3), roughness: 1.0 }
                ),
                
                new Sphere(
                    new Vec3(3.5, -0.5, -9),
                    0.5,
                    { type: MaterialType.METAL, albedo: new Vec3(0.9, 0.3, 0.3), roughness: 0.2 }
                )
            ]
        };
        
        // Camera setup
        function getCameraRay(x, y, wavelength = 0.0) {
            const aspect = WIDTH / HEIGHT;
            const fov = 50 * Math.PI / 180;
            const viewportHeight = 2.0 * Math.tan(fov / 2);
            const viewportWidth = aspect * viewportHeight;
            
            // Camera position with rotation
            const angle = settings.cameraRotation;
            const camX = 5 * Math.sin(angle);
            const camZ = -2 + 5 * Math.cos(angle);
            const cameraPos = new Vec3(camX, 2, camZ);
            const lookAt = new Vec3(0, 0, -8);
            const vup = new Vec3(0, 1, 0);
            
            const w = cameraPos.sub(lookAt).normalize();
            const u = vup.cross(w).normalize();
            const v = w.cross(u);
            
            const horizontal = u.mul(viewportWidth);
            const vertical = v.mul(viewportHeight);
            const lowerLeft = cameraPos
                .sub(horizontal.div(2))
                .sub(vertical.div(2))
                .sub(w);
            
            // Depth of field - lens sampling
            const rd = randomInUnitDisk().mul(settings.aperture);
            const offset = u.mul(rd.x).add(v.mul(rd.y));
            
            const s = x / WIDTH;
            const t = y / HEIGHT;
            
            // Add chromatic aberration offset based on wavelength
            const aberrationOffset = wavelength * settings.chromaticAberration;
            const sAberrated = s + aberrationOffset;
            
            const pointOnFocalPlane = lowerLeft
                .add(horizontal.mul(sAberrated))
                .add(vertical.mul(t));
            
            const focusPoint = cameraPos.add(
                pointOnFocalPlane.sub(cameraPos).normalize().mul(settings.focusDistance)
            );
            
            const origin = cameraPos.add(offset);
            const direction = focusPoint.sub(origin);
            
            return new Ray(origin, direction);
        }
        
        // Schlick's approximation for reflectance
        function schlick(cosine, ior) {
            let r0 = (1 - ior) / (1 + ior);
            r0 = r0 * r0;
            return r0 + (1 - r0) * Math.pow(1 - cosine, 5);
        }
        
        // Refract vector
        function refract(uv, n, etaiOverEtat) {
            const cosTheta = Math.min(n.mul(-1).dot(uv), 1.0);
            const rOutPerp = uv.add(n.mul(cosTheta)).mul(etaiOverEtat);
            const rOutParallel = n.mul(-Math.sqrt(Math.abs(1.0 - rOutPerp.dot(rOutPerp))));
            return rOutPerp.add(rOutParallel);
        }
        
        // Scene intersection
        function intersectScene(ray) {
            let closest = null;
            let minT = Infinity;
            
            for (const obj of scene.objects) {
                const hit = obj.intersect(ray, 0.001, minT);
                if (hit && hit.t < minT) {
                    minT = hit.t;
                    closest = hit;
                }
            }
            
            return closest;
        }
        
        // Volumetric scattering
        function volumetricScatter(ray, tMax) {
            if (settings.volumetricDensity <= 0) return null;
            
            const scatterDist = -Math.log(random()) / settings.volumetricDensity;
            
            if (scatterDist < tMax) {
                return {
                    point: ray.at(scatterDist),
                    scattered: true
                };
            }
            
            return null;
        }
        
        // Main ray tracing function
        function traceRay(ray, depth) {
            if (depth <= 0) {
                return new Vec3(0, 0, 0);
            }
            
            const hit = intersectScene(ray);
            
            if (!hit) {
                // Sky color
                const t = 0.5 * (ray.direction.y + 1.0);
                return new Vec3(0.3, 0.5, 0.8).mul(1 - t).add(new Vec3(0.8, 0.9, 1.0).mul(t)).mul(0.3);
            }
            
            const mat = hit.material;
            
            // Emissive material
            if (mat.type === MaterialType.EMISSIVE) {
                return mat.emission;
            }
            
            // Check for volumetric scattering before surface
            const volumeScatter = volumetricScatter(ray, hit.t);
            if (volumeScatter && volumeScatter.scattered) {
                const scatterDir = randomUnitVector();
                const newRay = new Ray(volumeScatter.point, scatterDir);
                return traceRay(newRay, depth - 1).mul(0.8);
            }
            
            let scattered;
            let attenuation;
            
            // Material scattering
            if (mat.type === MaterialType.DIFFUSE) {
                // Diffuse/Lambertian
                const scatterDir = hit.normal.add(randomUnitVector());
                scattered = new Ray(hit.point, scatterDir);
                attenuation = mat.albedo;
                
            } else if (mat.type === MaterialType.METAL) {
                // Metal with roughness
                const reflected = ray.direction.reflect(hit.normal);
                const scattered_dir = reflected.add(randomInUnitSphere().mul(mat.roughness));
                scattered = new Ray(hit.point, scattered_dir);
                attenuation = mat.albedo;
                
                if (scattered.direction.dot(hit.normal) <= 0) {
                    return new Vec3(0, 0, 0);
                }
                
            } else if (mat.type === MaterialType.GLASS) {
                // Glass/Dielectric
                attenuation = mat.albedo;
                const refractionRatio = hit.normal.dot(ray.direction) < 0 ? 1.0 / mat.ior : mat.ior;
                
                const unitDir = ray.direction.normalize();
                const cosTheta = Math.min(hit.normal.mul(-1).dot(unitDir), 1.0);
                const sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);
                
                const cannotRefract = refractionRatio * sinTheta > 1.0;
                let direction;
                
                if (cannotRefract || schlick(cosTheta, refractionRatio) > random()) {
                    direction = unitDir.reflect(hit.normal);
                } else {
                    direction = refract(unitDir, hit.normal, refractionRatio);
                }
                
                scattered = new Ray(hit.point, direction);
            }
            
            // Recursive ray tracing
            const incomingLight = traceRay(scattered, depth - 1);
            return incomingLight.mulVec(attenuation);
        }
        
        // Render one sample with chromatic aberration
        function renderPixelWithCA(x, y) {
            // RGB chromatic aberration - slightly offset rays for each channel
            const rRay = getCameraRay(x + random() - 0.5, y + random() - 0.5, -1);
            const gRay = getCameraRay(x + random() - 0.5, y + random() - 0.5, 0);
            const bRay = getCameraRay(x + random() - 0.5, y + random() - 0.5, 1);
            
            const rColor = traceRay(rRay, settings.maxBounces);
            const gColor = traceRay(gRay, settings.maxBounces);
            const bColor = traceRay(bRay, settings.maxBounces);
            
            return new Vec3(rColor.x, gColor.y, bColor.z);
        }
        
        // Render frame
        function render() {
            const startTime = performance.now();
            
            for (let s = 0; s < settings.samplesPerFrame; s++) {
                for (let y = 0; y < HEIGHT; y++) {
                    for (let x = 0; x < WIDTH; x++) {
                        const idx = (y * WIDTH + x) * 3;
                        
                        const color = renderPixelWithCA(x, y);
                        
                        accumBuffer[idx] += color.x;
                        accumBuffer[idx + 1] += color.y;
                        accumBuffer[idx + 2] += color.z;
                    }
                }
            }
            
            frameCount++;
            
            // Update display
            for (let y = 0; y < HEIGHT; y++) {
                for (let x = 0; x < WIDTH; x++) {
                    const idx = (y * WIDTH + x) * 3;
                    const pixelIdx = (y * WIDTH + x) * 4;
                    
                    const scale = 1.0 / frameCount;
                    
                    // Tone mapping and gamma correction
                    let r = Math.sqrt(accumBuffer[idx] * scale);
                    let g = Math.sqrt(accumBuffer[idx + 1] * scale);
                    let b = Math.sqrt(accumBuffer[idx + 2] * scale);
                    
                    imageData.data[pixelIdx] = Math.min(255, r * 255);
                    imageData.data[pixelIdx + 1] = Math.min(255, g * 255);
                    imageData.data[pixelIdx + 2] = Math.min(255, b * 255);
                    imageData.data[pixelIdx + 3] = 255;
                }
            }
            
            ctx.putImageData(imageData, 0, 0);
            
            // Update stats
            const currentTime = performance.now();
            fps = 1000 / (currentTime - lastTime);
            lastTime = currentTime;
            
            document.getElementById('frameCount').textContent = frameCount;
            document.getElementById('fps').textContent = fps.toFixed(1);
            
            requestAnimationFrame(render);
        }
        
        // Reset accumulation
        function resetAccumulation() {
            frameCount = 0;
            accumBuffer.fill(0);
        }
        
        // UI Controls
        document.getElementById('samples').addEventListener('input', (e) => {
            settings.samplesPerFrame = parseInt(e.target.value);
            document.getElementById('samplesValue').textContent = settings.samplesPerFrame;
            resetAccumulation();
        });
        
        document.getElementById('bounces').addEventListener('input', (e) => {
            settings.maxBounces = parseInt(e.target.value);
            document.getElementById('bouncesValue').textContent = settings.maxBounces;
            resetAccumulation();
        });
        
        document.getElementById('aperture').addEventListener('input', (e) => {
            settings.aperture = parseFloat(e.target.value);
            document.getElementById('apertureValue').textContent = settings.aperture.toFixed(2);
            resetAccumulation();
        });
        
        document.getElementById('focus').addEventListener('input', (e) => {
            settings.focusDistance = parseFloat(e.target.value);
            document.getElementById('focusValue').textContent = settings.focusDistance.toFixed(1);
            resetAccumulation();
        });
        
        document.getElementById('aberration').addEventListener('input', (e) => {
            settings.chromaticAberration = parseFloat(e.target.value);
            document.getElementById('aberrationValue').textContent = settings.chromaticAberration.toFixed(3);
            resetAccumulation();
        });
        
        document.getElementById('volume').addEventListener('input', (e) => {
            settings.volumetricDensity = parseFloat(e.target.value);
            document.getElementById('volumeValue').textContent = settings.volumetricDensity.toFixed(2);
            resetAccumulation();
        });
        
        document.getElementById('rotation').addEventListener('input', (e) => {
            settings.cameraRotation = parseFloat(e.target.value);
            document.getElementById('rotationValue').textContent = settings.cameraRotation.toFixed(1);
            resetAccumulation();
        });
        
        document.getElementById('reset').addEventListener('click', resetAccumulation);
        
        // Initialize
        document.getElementById('resolution').textContent = `${WIDTH}x${HEIGHT}`;
        render();
    </script>
</body>
</html>
