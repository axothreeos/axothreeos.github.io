<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Object Detection with MediaPipe + Three.js</title>
<style>
  body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: Arial, sans-serif; }
  #video { display: none; }
  canvas { display: block; }
  #log { position: absolute; top: 0; left: 0; z-index: 2; color: #0f0; padding: 4px; font-size: 14px; }
</style>
<!-- MediaPipe tasks-vision -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js" crossorigin="anonymous"></script>
<!-- THREE.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<div id="log">Initializingâ€¦</div>
<video id="video" playsinline autoplay muted></video>
<canvas id="three-canvas"></canvas>

<script>
(async () => {
  const log = document.getElementById("log");
  const video = document.getElementById("video");
  const canvas3D = document.getElementById("three-canvas");

  // Setup back camera
  async function setupBackCamera() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const backCam = devices.find(d => d.kind === "videoinput" && /back|rear/i.test(d.label));
    const props = backCam ? { video: { deviceId: { exact: backCam.deviceId }, width: 640, height: 480 } }
                          : { video: { facingMode: "environment", width: 640, height: 480 } };
    const stream = await navigator.mediaDevices.getUserMedia(props);
    video.srcObject = stream;
    return new Promise(r => video.onloadedmetadata = r);
  }

  await setupBackCamera();

  // Initialize Object Detector
  const { ObjectDetector, FilesetResolver } = window.tasksVision;
  const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");

  const objectDetector = await ObjectDetector.createFromOptions(vision, {
    baseOptions: { modelAssetPath: "models/efficientdet_lite2_float32.tflite" },
    scoreThreshold: 0.5,
    runningMode: "video",
  });

  log.textContent = "Detector loaded!";

  // THREE.js setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 10);
  const renderer = new THREE.WebGLRenderer({ canvas: canvas3D, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);

  // Orbit Controls (optional)
  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  // A group to hold 3D boxes
  const boxesGroup = new THREE.Group();
  scene.add(boxesGroup);

  // Render loop
  function render() {
    requestAnimationFrame(render);
    controls.update();
    renderer.render(scene, camera);
  }
  render();

  // Convert detection boxes into THREE.js boxes
  function draw3DObjects(detections) {
    // Clear old boxes
    boxesGroup.clear();

    detections.forEach(d => {
      const box = d.boundingBox;
      const label = d.categories[0].categoryName;
      const score = (d.categories[0].score * 100).toFixed(1);

      // Box center and scale
      const x = (box.xMin + (box.xMax - box.xMin)/2 - 0.5) * 10;
      const y = -(box.yMin + (box.yMax - box.yMin)/2 - 0.5) * 10;
      const w = (box.xMax - box.xMin) * 10;
      const h = (box.yMax - box.yMin) * 10;

      // Create 3D cube
      const geometry = new THREE.BoxGeometry(w, h, 0.1);
      const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
      const cube = new THREE.Mesh(geometry, material);
      cube.position.set(x, y, -1);
      boxesGroup.add(cube);

      // Label text
      const textGeom = new THREE.TextGeometry(`${label} ${score}%`, {
        font: new THREE.FontLoader().parse(THREE.FontUtils.extract(fontJSON)),
        size: 0.3,
        height: 0.02,
      });
      const textMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const textMesh = new THREE.Mesh(textGeom, textMat);
      textMesh.position.set(x - w/2, y + h/2, -1);
      boxesGroup.add(textMesh);
    });
  }

  let lastTime = -1;
  function detectLoop() {
    if (video.currentTime !== lastTime) {
      const results = objectDetector.detectForVideo(video, performance.now());
      draw3DObjects(results.detections);
      lastTime = video.currentTime;
    }
    requestAnimationFrame(detectLoop);
  }
  detectLoop();
})();
</script>
</body>
</html>
